# 웹 애플리케이션 서버
## 진행 방법
* 웹 애플리케이션 서버 요구사항을 파악한다.
* 요구사항에 대한 구현을 완료한 후 자신의 github 아이디에 해당하는 브랜치에 Pull Request(이하 PR)를 통해 코드 리뷰 요청을 한다.
* 다음 단계를 도전하고 앞의 과정을 반복한다.
* 코드 리뷰가 완료되면 피드백에 대한 개선 작업을 한다.
* 다음 단계 PR 보낼 때 이전 단계 피드백이 잘 반영되었는지 점검한다.

## 온라인 코드 리뷰 과정
* [텍스트와 이미지로 살펴보는 코드스쿼드의 온라인 코드 리뷰 과정](https://github.com/code-squad/codesquad-docs/blob/master/codereview/README.md)
* [동영상으로 살펴보는 코드스쿼드의 온라인 코드 리뷰 과정](https://youtu.be/a5c9ku-_fok)

## 학습한 점
* BufferedReader는 InputStream 등 다양한 입력 스트림을 편하게 관리해주는 클래스이다.
* HTTP Request의 마지막 라인은 ```""``` 로 빈 문자열이 들어간다.
* index.html로 연결을 시도했는데 favicon.ico에 대한 연결도 브라우저가 자동으로 시도한다. 이는 아이콘을 가져오기 위한 것으로 보인다.
* 첫 번째와 두 번째 라인을 확인해보니 클라이언트로부터 2가지의 요청이 발생했다. 각 요청마다 쓰레드가 별도로 생기며, 서로 다른 포트로 연결된다.
* 첫 번쨰 라인은 request line이라고 부르고, 이후의 요청에는 마지막 라인 전까지 ```<필드 값> : <필드 이름>``` 으로 구성되어 있다.
* 서버는 웹 페이지를 구성하는 모든 자원을 한 번에 응답으로 보내지 않는다. 첫 번째로 ```/index.html``` 요청에 대한 응답에 HTML만 보낸다.
    * 응답을 받은 브라우저는 HTML 내용을 분석해 CSS, 자바스크립트, 이미지 등의 자원이 포함되어 있으면 서버에 해당 자원을 다시 요청하게 된다.
    * 따라서 하나의 웹 페이지를 사용자에게 정상적으로 서비스하려면 클라이언트와 서버 간에 한 번의 요청이 아닌 여러 번의 요청과 응답을 주고 받게 된다.
* 6단계 이전까지 응답을 보낼 때 모든 컨텐츠의 타입을 text/html로 보냈다. 브라우저는 응답을 받은 후 Content-Type 헤더 값을 통해 본문의 컨텐츠를 확인한다.
    * 하지만 지금까지는 text/html로 고정되어 있어 브라우저는 CSS 파일도 HTML로 인식했다. 요청 URL의 확장자가 CSS이면 text/css로 응답을 보내도록 구현해본다.